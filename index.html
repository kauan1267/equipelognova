<script>
  const slides = ["slide1", "slide2", "slide3"];
  let currentSlide = 0;

  const secoes = [
    {
      titulo: "üìù INFORMA√á√ïES INICIAIS",
      perguntas: [
        "1. Nome + ID Discord",
        "2. Qual seu hor√°rio dispon√≠vel pra ajudar na LOG?",
        "3. Atua em alguma √°rea da staff? Se sim, quais?",
        "4. J√° teve experi√™ncia como Equipe LOG? Se sim, me diga mais sobre."
      ]
    },
    {
      titulo: "üîß CONHECIMENTOS B√ÅSICOS DE COMANDOS",
      perguntas: [
        "5. Pra que serve o comando /hackperma? E quando ele deve ser usado?",
        "6. Em quais situa√ß√µes o /propmanager seria ideal para achar hacker?",
        "7. Pra que serve o /delobjs? E em quais situa√ß√µes seria necess√°rio us√°-lo?",
        "8. Pra que serve o /forcedelete? E por que ele pode ser usado quando o /delobjs n√£o funcionar?",
        "9. Como voc√™ poderia achar o hack que usa fun√ß√£o do mod menu pra falar alto?",
        "10. Se voc√™ banir um hacker e ele n√£o for kikado da cidade, o que voc√™ poderia fazer?",
        "11. Se voc√™ ver um hacker zaralhando na cidade, o que voc√™ faria?",
        "12. Est√° ciente que ter√° uma meta semanal de 50 banimentos? (Sim ou N√£o)",
        "13. Se algu√©m te marcar num ticket falando que o dinheiro dele sumiu, o que voc√™ faria?",
        "14. Mostre que voc√™ estava atento nas perguntas: quais comandos citados acima n√£o existem?"
      ]
    },
    {
      titulo: "üß† COMANDOS AVAN√áADOS E AN√ÅLISE T√âCNICA",
      perguntas: [
        "15. O que √© o comando /hban e para que serve?",
        "16. Qual a diferen√ßa entre /hban e /hban2? Em que situa√ß√µes cada um deve ser usado?",
        "17. Para que serve o comando /cleanarea? E qual a diferen√ßa para /cleanarea area?",
        "18. Para que serve o comando /vozes e como ele ajuda na identifica√ß√£o de hacker?",
        "19. Como o comando /wallconfig source pode ser usado em uma investiga√ß√£o?",
        "20. Explique a fun√ß√£o dos seguintes comandos e quando cada um deve ser usado:",
        "‚Ä¢ /bansrc source",
        "‚Ä¢ /kicksrc source",
        "‚Ä¢ /tptosrc source",
        "‚Ä¢ /idsrc source"
      ]
    },
    {
      titulo: "üîé SITUA√á√ïES PR√ÅTICAS E TOMADA DE DECIS√ÉO",
      perguntas: [
        "21. Voc√™ viu um carro spawnado na pra√ßa e quer saber quem √© o dono. Qual comando usaria e o que ele mostra?",
        "22. Explique a import√¢ncia de saber a diferen√ßa entre ID e source na identifica√ß√£o de hackers.",
        "23. Caso um hacker esteja travando o /hban, como voc√™ agiria? Quais comandos usaria e em qual ordem?",
        "24. D√™ um exemplo pr√°tico de como voc√™ identificaria e lidaria com um ataque hacker envolvendo spawn de objetos e voz global."
      ]
    },
    {
      titulo: "‚ö†Ô∏è COMPROMETIMENTO COM A EQUIPE",
      perguntas: [
        "25. Voc√™ est√° ciente de que a equipe LOG √© a principal respons√°vel por combater hackers na cidade, e que a responsabilidade √© alta? Est√° disposto a assumir esse compromisso sabendo que, caso n√£o bata a meta semanal de banimentos, poder√° ser removido da equipe?",
        "Tamb√©m est√° ciente de que em qualquer momento poder√£o ser feitas perguntas-surpresa sobre os comandos e situa√ß√µes citadas acima e, caso n√£o saiba responder corretamente, poder√° ser punido por estar colando ou n√£o estar realmente preparado?"
      ]
    }
  ];

  let respostas = {};
  let secaoAtual = 0;
  let perguntaAtual = 0;

  let tempoRestante = 24 * 60;
  let timerInterval;

  function showSlide(index) {
    if (slides[index - 1]) document.getElementById(slides[index - 1]).classList.add("hidden");
    if (slides[index]) document.getElementById(slides[index]).classList.remove("hidden");
  }

  let slideInterval = setInterval(() => {
    currentSlide++;
    if (currentSlide < slides.length) {
      showSlide(currentSlide);
    } else {
      clearInterval(slideInterval);
    }
  }, 3500);

  function startForm() {
    slides.forEach(id => document.getElementById(id).classList.add("hidden"));
    document.getElementById("formCard").classList.remove("hidden");
    perguntaAtual = 0;
    secaoAtual = 0;
    mostrarPergunta();
    iniciarContador();
  }

  function iniciarContador() {
    const timerDisplay = document.getElementById("timer");
    timerInterval = setInterval(() => {
      if (tempoRestante <= 0) {
        clearInterval(timerInterval);
        document.getElementById("formCard").innerHTML = "<h2>‚è± Tempo esgotado! Formul√°rio encerrado.</h2>";
        return;
      }
      const minutos = Math.floor(tempoRestante / 60);
      const segundos = tempoRestante % 60;
      timerDisplay.textContent = `${minutos.toString().padStart(2, '0')}:${segundos.toString().padStart(2, '0')}`;
      tempoRestante--;
    }, 1000);
  }

  function mostrarPergunta() {
    const secao = secoes[secaoAtual];
    const pergunta = secao.perguntas[perguntaAtual];

    document.getElementById("sectionTitle").innerText = secao.titulo;
    document.getElementById("questionText").innerText = pergunta;
    document.getElementById("answerInput").value = "";
    document.getElementById("progressBar").style.width = 
      (((getPerguntasRespondidasCount() / getTotalPerguntas()) * 100) + "%");

    document.getElementById("answerInput").focus();
  }

  function nextQuestion() {
    const resposta = document.getElementById("answerInput").value.trim();
    if (!resposta) {
      alert("Por favor, responda antes de continuar.");
      return;
    }

    const secao = secoes[secaoAtual];
    const pergunta = secao.perguntas[perguntaAtual];

    respostas[pergunta] = resposta;
    perguntaAtual++;

    if (perguntaAtual >= secao.perguntas.length) {
      if (secaoAtual < secoes.length - 1) {
        document.getElementById("formCard").classList.add("hidden");
        document.getElementById("confirmSection").classList.remove("hidden");
        document.getElementById("confirmTitle").innerText = `Voc√™ concluiu a se√ß√£o: ${secao.titulo}`;
        perguntaAtual = 0;
      } else {
        finalizarFormulario();
      }
    } else {
      mostrarPergunta();
    }
  }

  function continueSection() {
    document.getElementById("confirmSection").classList.add("hidden");
    document.getElementById("formCard").classList.remove("hidden");
    secaoAtual++;
    mostrarPergunta();
  }

  function finalizarFormulario() {
    document.getElementById("formCard").classList.add("hidden");
    document.getElementById("finalPage").classList.remove("hidden");
    clearInterval(timerInterval);
    enviarParaWebhook();
  }

  function getTotalPerguntas() {
    return secoes.reduce((acc, s) => acc + s.perguntas.length, 0);
  }

  function getPerguntasRespondidasCount() {
    let count = 0;
    for(let i = 0; i < secaoAtual; i++) {
      count += secoes[i].perguntas.length;
    }
    count += perguntaAtual;
    return count;
  }

  function chunkArray(arr, size) {
    const chunks = [];
    for(let i = 0; i < arr.length; i += size) {
      chunks.push(arr.slice(i, i + size));
    }
    return chunks;
  }

  // Fun√ß√£o para dividir textos longos em peda√ßos <= 1024 caracteres (limite do Discord)
  function splitLongText(text, maxLength = 1024) {
    const result = [];
    let start = 0;
    while (start < text.length) {
      result.push(text.substring(start, start + maxLength));
      start += maxLength;
    }
    return result;
  }

  async function enviarParaWebhook() {
  const webhookURL = "https://discord.com/api/webhooks/1397640296698740826/UJqim4Wfp-MZyAkRGy9f4YacQLac5yeeDxWaFl3TzucovKWS3ga44ChNrtRGFqdd5p9N";

  const maxSmallResponseLength = 400; // at√© 400 chars respostas pequenas

  let combinedFields = [];
  let tempCombinedName = "";
  let tempCombinedValue = "";

  for (const [pergunta, resposta] of Object.entries(respostas)) {
    const res = resposta || "Sem resposta";

    if (res.length <= maxSmallResponseLength) {
      if ((tempCombinedValue.length + res.length + 4) <= 1024) {
        tempCombinedName += (tempCombinedName ? "\n\n" : "") + pergunta;
        tempCombinedValue += (tempCombinedValue ? "\n\n" : "") + res;
      } else {
        combinedFields.push({
          name: tempCombinedName || "Respostas agrupadas",
          value: tempCombinedValue || "Sem resposta",
          inline: false
        });
        tempCombinedName = pergunta;
        tempCombinedValue = res;
      }
    } else {
      if (tempCombinedValue) {
        combinedFields.push({
          name: tempCombinedName || "Respostas agrupadas",
          value: tempCombinedValue || "Sem resposta",
          inline: false
        });
        tempCombinedName = "";
        tempCombinedValue = "";
      }

      // Divide respostas longas
      const partes = splitLongText(res, 1024);
      if (partes.length === 1) {
        combinedFields.push({
          name: pergunta,
          value: partes[0],
          inline: false
        });
      } else {
        partes.forEach((parte, i) => {
          combinedFields.push({
            name: `${pergunta} (parte ${i + 1}/${partes.length})`,
            value: parte,
            inline: false
          });
        });
      }
    }
  }

  // Ap√≥s o loop, envia o que ficou pendente agrupado
  if (tempCombinedValue) {
    combinedFields.push({
      name: tempCombinedName || "Respostas agrupadas",
      value: tempCombinedValue || "Sem resposta",
      inline: false
    });
  }

  // Agora dividimos em chunks de 25 campos (limite Discord)
  const chunks = chunkArray(combinedFields, 25);

  for (const [index, chunk] of chunks.entries()) {
    const payload = {
      embeds: [{
        title: `üì® Nova Resposta - Formul√°rio Equipe LOG${chunks.length > 1 ? ` (Parte ${index + 1}/${chunks.length})` : ""}`,
        color: 3447003,
        fields: chunk,
        timestamp: new Date()
      }]
    };

    try {
      const response = await fetch(webhookURL, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload)
      });

      if (!response.ok) {
        console.error("Erro ao enviar webhook:", response.statusText);
      }
    } catch (error) {
      console.error("Erro ao enviar webhook:", error);
    }
  }
}
